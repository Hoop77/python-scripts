#     __                            __                                                                 
#    / /_     ___     ____ _   ____/ /  ___     _____   ____ _   ___     ____           ____     __  __
#   / __ \   / _ \   / __ `/  / __  /  / _ \   / ___/  / __ `/  / _ \   / __ \         / __ \   / / / /
#  / / / /  /  __/  / /_/ /  / /_/ /  /  __/  / /     / /_/ /  /  __/  / / / /   _    / /_/ /  / /_/ / 
# /_/ /_/   \___/   \__,_/   \__,_/   \___/  /_/      \__, /   \___/  /_/ /_/   (_)  / .___/   \__, /  
#                                                    /____/                         /_/       /____/   
# 
# -*- coding: utf-8 -*-

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#
# MODULE DESCRIPTION
# ------------------
# This module puts a text at the top of a given text-/sourcefile which could
# be a header generated by figlet. For every line generated you have the option
# to put a string at the begin and end of the generated line (e.g. a comment-string)
# 
# ARGUMENTS
# ---------
# headergen.py -f <filename> -t <text> -b <lineBegin> -e <lineEnd>
#
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

import sys, os, argparse, datetime

# kill ""-signes if they occur at the beginning and at the end of the argument
def evalArg( arg ):
	result = ''

	# check empty
	if arg == '':
		return ''

	# check if ""-signs exist
	l = len( arg )
	if arg[ 0 ] == '"' and arg[ l - 1 ] == '"':
		result = arg[ 1 : l - 2 ]
	else:
		result = arg

	return result

# main
if __name__ == '__main__':

	# create command line interface
	parser = argparse.ArgumentParser( description = 'This module puts a text at the top of a given text-/sourcefile (which could be a header generated by figlet for example). For every generated line you you can put a string at the beginning and end of that line (e.g. a comment-string)' )

	parser.add_argument( 'file', metavar = 'FILE', help = 'the filename of the file to add text to' )
	parser.add_argument( '-t', '--text', metavar = '', help = 'the text which is going to be pasted at the beginning of the file' )
	parser.add_argument( '-b', '--line-begin', metavar = '', help = 'a string that is put at the beginning of each line of the given text' )
	parser.add_argument( '-e', '--line-end', metavar = '', help = 'a string that is put at the end of each line of the given text' )
	parser.add_argument( '--generate-method', metavar = '', help = 'a custom method of generating the text' )

	args = parser.parse_args()

	# variables needed
	filename = os.getcwd() + '/' + evalArg( args.file )		# not-None-check is not necessary because of argparse

	text = ''
	lineBegin = ''
	lineEnd = ''
	generateMethod = ''

	if args.text is not None:
		text = evalArg( args.text )
	if args.line_begin is not None:	
		lineBegin = evalArg( args.line_begin )
	if args.line_end is not None:
		lineEnd = evalArg( args.line_end )
	if args.generate_method is not None:
		generateMethod = evalArg( args.generate_method )

	# generate text with figlet
	if generateMethod != '':							# custom way to generate text
		f = os.popen( generateMethod + ' ' + text )
	else:												# default: generate text with figlet
		f = os.popen( 'figlet -w 1000 -f slant ' + text )

	gen = f.read()

	# add lineBegin and lineEnd to every line
	addedLines = gen.split( '\n' )
	for i in range( len( addedLines )):
		addedLines[ i ] = lineBegin \
						+ addedLines[ i ] \
						+ lineEnd \
						+ '\n'

	# merge contents of the file given and the new text in a temp file
	# ----------------------------------------------------------------
	# create a temp file which will be the output file
	tempfile = os.getcwd() + '/' + datetime.datetime.now().strftime( '%Y%m%d%H%M%S%f' )

	# open streams
	finput = open( filename, 'r' )
	foutput = open( tempfile, 'w' )

	# add lines of generated text first
	for line in addedLines:
		foutput.write( line )

	# then add lines of file
	for line in finput:
		foutput.write( line )

	# close streams
	finput.close()
	foutput.close()

	# delete the old file and rename the tempfile as it's the new file now
	os.remove( filename )
	os.rename( tempfile, filename )

